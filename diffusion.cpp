//Program to calculate predicted sigma values for loci in a model system, where data is generated by a sampling process
//This code uses a deterministic method to run the underlying population distribution, and samples it at low frequency

#include <iostream>
#include <vector>
#include <list>
#include <deque>
using namespace std;

#include "diffusion.h"
#include "absorbing.h"
#include "reflecting.h"
#include "data.h"
#include "io.h"
#include "analysis.h"
#include "utilities.h"

int main(int argc, const char *argv[]){

    //Command line input
    options o;
    GetCMLOptions (o,argc,argv);
    
    //Read in data describing parameters
    param p;
    ReadParameters(o,p);

    //Set up random number generator
    gsl_rng_env_setup();
    gsl_rng *rgen = gsl_rng_alloc (gsl_rng_taus);
    gsl_rng_set (rgen, o.seed);
    double Pi=3.1415926535897932385;

    if (o.method.compare("Analysis")==0) {
        RunAnalysis (o,p,Pi,rgen);
        return 0;
    }

    if (o.method.compare("Generation")==0) {
        //Evaporation of particles
        double radius=EvaporationModel(o.radius);
        if (o.verb==1) {
            cout << "Post-evaporation radius " << radius << "\n";
        }
        //Generate loss parameter
        FindLambda(o,p,radius);
                
        //Read in locations of individuals.  First is the infected person.  Locations.dat is X, Z
        vector<loc> locations;
        ReadLocations(o,p,locations);
        
        //Read in initial condition as specified by coughing model - datapoints
        vector<dist> initial;
        ReadCough(o,p,initial);
        
        //Find the mean position of the cough.
        FindEmissionMean (o,p,initial);

        if (o.absorbing==1) {
            //Find the time which best fits the model, calculated across the grid.
            //Option to find t_0.  Currently this terminates the code
            if (o.opt_t0==1) {
                double t=0.01;
                OptimiseInitialTAbsorbing (o,p,t,Pi,initial,rgen);
                return 0;
            } else {
                GetPrecalcT0Absorbing(o,p);
            }
            
            //In order to generate an estimate of the total emissions, calculate a grid of 2cm resolution at time zero=t_0
            cout << "Calculating total exposure...\n";
            double total_exp_init=0;
            if (o.shorrt==1) {
                CalculateTotalExposureAbsorbing(o,p,Pi,total_exp_init);
                return 0;
            }

            CalculateTotalExposureAbsorbing(o,p,Pi,total_exp_init);

            
            if (o.test_output==1) {
                CalcluateExposuresAbsorbingTest(o,p,Pi,total_exp_init);
                return 0;
            }
            
            //In practice we want to calculate exposures at each of the points.  Create a grid of points around each one at 2cm resolution
            cout << "Generating location grids...\n";
            //Make location grids
            vector< vector<loc> > location_grids;
            MakeLocationGrids (o,p,locations,location_grids);
            
            //Find average exposure at each location: Within a 40cm square: Mean of included grid points.  One second resolution.
            vector< vector<double> > exp_record;
            vector<double> times;
            CalcluateExposuresAbsorbing(o,p,Pi,total_exp_init,location_grids,times,exp_record);

            //Output data to a file
            ExportExposures (o,times,exp_record);
            
            return 0;
        } else {
            /*
            //Basic test of diffusion equation
            double x=5.5;
            double y=5.6;
            double x_0=5;
            double y_0=5;
            double k=7;
            double lambda=3;
            double t=0.1;
            double test=dref(x,x_0,y,y_0,k,lambda,t);
            cout << "Test 1 " << test  << "\n";
            double A=10;
            double B=10;
            double reps=5;
            double test2=sumreflections (A,B,reps,x,x_0,y,y_0,k,lambda,t);
            cout << "Test 2 " << test2  << "\n";
*/
            if (o.opt_t0==1) {
                double t=0.01;
                OptimiseInitialTReflecting (o,p,t,Pi,initial,rgen);
                return 0;
                //Need code to optimise t_0
            } else {
                GetPrecalcT0Reflecting(o,p);
            }
            
            //In order to generate an estimate of the total emissions, calculate a grid of 2cm resolution at time zero=t_0
            cout << "Calculating total exposure...\n";
            double total_exp_init=0;
            CalculateTotalExposureReflecting(o,p,Pi,total_exp_init);
           
	   if (total_exp_init==0) {
		  cout << "Error: Zero total\n";
	   	return 0;
	   } 
            //In practice we want to calculate exposures at each of the points.  Create a grid of points around each one at 2cm resolution
            cout << "Generating location grids...\n";
            //Make location grids
            vector< vector<loc> > location_grids;
            MakeLocationGrids (o,p,locations,location_grids);

            cout << "Calculate Exposures\n";
            //Find average exposure at each location: Within a 40cm square: Mean of included grid points.  One second resolution.
            vector< vector<double> > exp_record;
            vector<double> times;
            CalcluateExposuresReflecting(o,p,Pi,total_exp_init,location_grids,times,exp_record);

            //Output data to a file
            ExportExposures (o,times,exp_record);

            return 0;
        }
    }
    
    
    
    
    
    
    

    
    
    
    
    //To do next:
    //3. Run for all office - multiple r values
    //4. Generate code for the reflecting boundary conditions
    
    //5.  If we generate output files, we can potnetially do the sampling faster in C++.  More code for this?
    
	return 0;
}
	
	
